<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MoreTranz Halftone Tool</title>
    <style>
      body { font-family: Arial, sans-serif; max-width: 1120px; margin: 24px auto; padding: 0 16px; }

      /* Two-column layout: left grows, right stays a fixed column */
      .row {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        justify-content: center;
      }

      .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; background: #fff; }
      label { display:block; font-size: 14px; margin: 12px 0 6px; font-weight: 600; }
      input[type="range"] { width: 100%; }
      select, input[type="file"], input[type="text"], button { width: 100%; padding: 10px; font-size: 14px; box-sizing: border-box; }
      button { cursor: pointer; }
      button:disabled { opacity: .6; cursor: not-allowed; }
      .muted { color:#666; font-size: 12px; line-height: 1.35; }
      .ok { color: #0a7a0a; }
      .err { color: #b00020; white-space: pre-wrap; }
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; }
      .pill { display:inline-block; padding: 3px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color:#333; background:#fafafa; }
      .btnRow { display:flex; gap:10px; }
      .btnRow button { width: 100%; }

      .toggleRow {
        display:flex; align-items:center; justify-content:space-between; gap:12px;
        padding:10px 12px; border:1px solid #eee; border-radius:10px; background:#fafafa;
      }
      .toggleRow input { width:auto; transform: scale(1.15); }

      details { margin-top: 12px; }
      details > summary { cursor: pointer; font-weight: 600; }
      .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }

      /* Left column: flexible */
      .leftCol { flex: 1 1 520px; min-width: 360px; }

      /* Right column: fixed width, doesn't stretch full screen */
      .rightCol { flex: 0 0 480px; max-width: 480px; }

      /* Previews: stacked, constrained */
      .previewImg {
        width: 100%;
        max-width: 100%;
        max-height: 420px;
        height: auto;
        display: block;
        border: 1px solid #eee;
        border-radius: 10px;
        background: repeating-conic-gradient(#f6f6f6 0% 25%, #ffffff 0% 50%) 50% / 16px 16px;
        object-fit: contain;
      }

      /* Responsive: stack columns on small screens */
      @media (max-width: 980px) {
        .row { flex-wrap: wrap; }
        .rightCol { flex: 1 1 520px; max-width: none; }
      }

      @media (max-width: 720px) {
        .grid2 { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <h1 style="margin-bottom:8px;">MoreTranz Halftone Tool</h1>
    <p class="muted" style="margin-top:0;">
      Uploads to Cloudflare R2, processes on Render, returns a downloadable PNG.
      <span class="pill">Tip: 12&quot; @ 300dpi = 3600px</span>
      <span class="pill">DTF-safe output (binary alpha)</span>
    </p>

    <div class="row">
      <div class="card leftCol">
        <h3 style="margin-top:0;">1) Choose image</h3>
        <input id="file" type="file" accept="image/png,image/jpeg,image/webp" />
        <div id="fileInfo" class="muted" style="margin-top:6px;"></div>

        <hr style="border:none;border-top:1px solid #eee;margin:16px 0;"/>

        <h3 style="margin:0 0 8px;">2) Settings</h3>

        <label>Dot shape</label>
        <select id="dotShape">
          <option value="circle" selected>circle (default)</option>
          <option value="ellipse">ellipse</option>
          <option value="square">square</option>
        </select>

        <label>Cell size: <span id="cellSizeVal">12</span></label>
        <input id="cellSize" type="range" min="8" max="30" step="1" value="12" />
        <div class="muted">Smaller = more detail but more CPU/RAM.</div>

        <label style="margin-top:14px;">Max width: <span id="maxWidthVal">2000</span> px</label>
        <input id="maxWidth" type="range" min="500" max="3600" step="50" value="2000" />
        <div class="muted">For 12&quot; @ 300dpi, use 3600. Reduce if performance is slow.</div>

        <div class="toggleRow" style="margin-top:14px;">
          <div>
            <div style="font-weight:700;">DTF Safe Mode</div>
            <div class="muted">Binary alpha + thresholds to prevent unwanted white underbase.</div>
          </div>
          <input id="dtfSafe" type="checkbox" checked />
        </div>

        <div class="grid2" style="margin-top:10px;">
          <div>
            <label>Darkness (dot gain): <span id="dotGainVal">1.25</span></label>
            <input id="dotGain" type="range" min="0.80" max="1.80" step="0.05" value="1.25" />
            <div class="muted">Higher = darker (more dot coverage).</div>
          </div>
          <div>
            <label>Min dot: <span id="minDotVal">0.18</span></label>
            <input id="minDot" type="range" min="0.00" max="0.40" step="0.01" value="0.18" />
            <div class="muted">Raises highlight dot size to hold brightness in print.</div>
          </div>
        </div>

        <details>
          <summary>Advanced (DTF thresholds)</summary>

          <div class="grid2" style="margin-top:10px;">
            <div>
              <label>Alpha threshold: <span id="alphaThresholdVal">32</span></label>
              <!-- min=1 so alpha=0 never counts -->
              <input id="alphaThreshold" type="range" min="1" max="200" step="1" value="32" />
              <div class="muted">Ignore pixels with alpha ≤ threshold. Increase to reduce halos.</div>
            </div>

            <div>
              <label>Min coverage: <span id="minCoverageVal">0.15</span></label>
              <input id="minCoverage" type="range" min="0.00" max="0.60" step="0.01" value="0.15" />
              <div class="muted">Cell must have this % of solid pixels to emit a dot.</div>
            </div>
          </div>

          <label style="margin-top:12px;">Alpha mode</label>
          <select id="alphaMode">
            <option value="binary" selected>binary (DTF recommended)</option>
            <option value="average">average (can create faint pixels)</option>
          </select>
        </details>

        <label style="margin-top:14px;">API base URL</label>
        <input id="apiBase" class="mono" value="https://moretranz-halftone.onrender.com" />

        <div class="btnRow" style="margin-top:14px;">
          <button id="go">Generate Halftone</button>
          <button id="reset" type="button">Reset defaults</button>
        </div>

        <div id="status" style="margin-top:12px;"></div>
        <div id="debug" class="mono muted" style="margin-top:10px;"></div>
      </div>

      <div class="card rightCol">
        <h3 style="margin-top:0;">Preview</h3>

        <div class="muted">Original</div>
        <img id="origPreview" class="previewImg" alt="" />

        <div style="height:10px;"></div>

        <div class="muted">Halftone output</div>
        <img id="outPreview" class="previewImg" alt="" />

        <button id="download" style="margin-top:12px;" disabled>Download PNG</button>

        <div class="muted" style="margin-top:10px;">
          If you see dots outside the artwork: increase Alpha threshold (try 40–60).
        </div>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);

      const fileEl = $("file");
      const fileInfo = $("fileInfo");
      const origPreview = $("origPreview");
      const outPreview = $("outPreview");
      const statusEl = $("status");
      const debugEl = $("debug");
      const goBtn = $("go");
      const resetBtn = $("reset");
      const dlBtn = $("download");
      const apiBase = $("apiBase");

      const cellSize = $("cellSize");
      const maxWidth = $("maxWidth");
      const dotShape = $("dotShape");
      const cellSizeVal = $("cellSizeVal");
      const maxWidthVal = $("maxWidthVal");

      const dtfSafe = $("dtfSafe");
      const dotGain = $("dotGain");
      const minDot = $("minDot");
      const dotGainVal = $("dotGainVal");
      const minDotVal = $("minDotVal");

      const alphaThreshold = $("alphaThreshold");
      const minCoverage = $("minCoverage");
      const alphaMode = $("alphaMode");
      const alphaThresholdVal = $("alphaThresholdVal");
      const minCoverageVal = $("minCoverageVal");

      const DEFAULTS = {
        dotShape: "circle",
        cellSize: 12,
        maxWidth: 2000,
        apiBase: "https://moretranz-halftone.onrender.com",

        dtfSafe: true,
        dotGain: 1.25,
        minDot: 0.18,
        alphaThreshold: 32,
        minCoverage: 0.15,
        alphaMode: "binary",
      };

      cellSize.addEventListener("input", () => (cellSizeVal.textContent = cellSize.value));
      maxWidth.addEventListener("input", () => (maxWidthVal.textContent = maxWidth.value));
      dotGain.addEventListener("input", () => (dotGainVal.textContent = dotGain.value));
      minDot.addEventListener("input", () => (minDotVal.textContent = minDot.value));
      alphaThreshold.addEventListener("input", () => (alphaThresholdVal.textContent = alphaThreshold.value));
      minCoverage.addEventListener("input", () => (minCoverageVal.textContent = Number(minCoverage.value).toFixed(2)));

      function applyDtfSafeUiState() {
        if (dtfSafe.checked) {
          alphaMode.value = "binary";
          if (Number(alphaThreshold.value) < 1) {
            alphaThreshold.value = 1;
            alphaThresholdVal.textContent = "1";
          }
        }
      }
      dtfSafe.addEventListener("change", applyDtfSafeUiState);

      let lastDownloadUrl = null;

      resetBtn.addEventListener("click", () => {
        dotShape.value = DEFAULTS.dotShape;
        cellSize.value = DEFAULTS.cellSize;
        maxWidth.value = DEFAULTS.maxWidth;
        apiBase.value = DEFAULTS.apiBase;

        dtfSafe.checked = DEFAULTS.dtfSafe;
        dotGain.value = DEFAULTS.dotGain;
        minDot.value = DEFAULTS.minDot;
        alphaThreshold.value = DEFAULTS.alphaThreshold;
        minCoverage.value = DEFAULTS.minCoverage;
        alphaMode.value = DEFAULTS.alphaMode;

        cellSizeVal.textContent = DEFAULTS.cellSize;
        maxWidthVal.textContent = DEFAULTS.maxWidth;
        dotGainVal.textContent = DEFAULTS.dotGain;
        minDotVal.textContent = DEFAULTS.minDot;
        alphaThresholdVal.textContent = DEFAULTS.alphaThreshold;
        minCoverageVal.textContent = Number(DEFAULTS.minCoverage).toFixed(2);

        applyDtfSafeUiState();
        setStatus("");
        setDebug("");
      });

      fileEl.addEventListener("change", () => {
        const f = fileEl.files?.[0];
        if (!f) return;

        fileInfo.textContent = `${f.name} — ${f.type || "unknown"} — ${f.size.toLocaleString()} bytes`;
        origPreview.src = URL.createObjectURL(f);

        outPreview.removeAttribute("src");
        dlBtn.disabled = true;
        lastDownloadUrl = null;

        setStatus("");
        setDebug("");
      });

      function setStatus(msg, kind="") {
        statusEl.className = kind === "err" ? "err" : (kind === "ok" ? "ok" : "");
        statusEl.textContent = msg;
      }

      function setDebug(msg) {
        debugEl.textContent = msg;
      }

      async function jsonOrText(resp) {
        const ct = resp.headers.get("content-type") || "";
        if (ct.includes("application/json")) return resp.json();
        return resp.text();
      }

      function normalizeBaseUrl(raw) {
        return String(raw || "").trim().replace(/\/+$/, "");
      }

      function friendlyNetworkError(err) {
        const m = String(err?.message || err || "");
        if (m.includes("Failed to fetch")) {
          return [
            "Failed to fetch",
            "",
            "This usually means the API was temporarily unavailable (restart) or your browser blocked the request.",
            "Try again in 5–10 seconds.",
          ].join("\n");
        }
        return m;
      }

      async function fetchWithRetry(url, opts, { tries = 2, delayMs = 700 } = {}) {
        let lastErr;
        for (let i = 0; i < tries; i++) {
          try {
            return await fetch(url, opts);
          } catch (e) {
            lastErr = e;
            if (i < tries - 1) await new Promise(r => setTimeout(r, delayMs));
          }
        }
        throw lastErr;
      }

      goBtn.addEventListener("click", async () => {
        const f = fileEl.files?.[0];
        if (!f) return setStatus("Please choose an image first.", "err");

        const allowed = ["image/png", "image/jpeg", "image/webp"];
        if (!allowed.includes(f.type)) return setStatus(`Unsupported type: ${f.type}`, "err");

        const base = normalizeBaseUrl(apiBase.value);
        if (!base.startsWith("http")) return setStatus("API base URL must start with http/https.", "err");

        const cs = Number(cellSize.value);
        const mw = Number(maxWidth.value);

        setStatus("Working…");
        setDebug("");
        goBtn.disabled = true;
        resetBtn.disabled = true;
        dlBtn.disabled = true;

        try {
          const upResp = await fetchWithRetry(`${base}/v1/halftone/upload-url`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              filename: f.name,
              contentType: f.type,
              contentLength: f.size
            })
          }, { tries: 2, delayMs: 500 });

          if (!upResp.ok) {
            const body = await jsonOrText(upResp);
            throw new Error(`upload-url failed (${upResp.status}): ${JSON.stringify(body, null, 2)}`);
          }

          const up = await upResp.json();

          const putResp = await fetchWithRetry(up.uploadUrl, {
            method: "PUT",
            headers: up.headers || { "Content-Type": f.type },
            body: f
          }, { tries: 2, delayMs: 500 });

          if (!putResp.ok) {
            const txt = await putResp.text().catch(() => "");
            throw new Error(`R2 PUT failed (${putResp.status}): ${txt || "no body"}`);
          }

          const payload = {
            key: up.key,
            cellSize: cs,
            maxWidth: mw,
            dotShape: dotShape.value,

            dotGain: Number(dotGain.value),
            minDot: Number(minDot.value),

            alphaThreshold: Number(alphaThreshold.value),
            minCoverage: Number(minCoverage.value),
            alphaMode: dtfSafe.checked ? "binary" : alphaMode.value,
          };

          const procResp = await fetchWithRetry(`${base}/v1/halftone/process`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          }, { tries: 2, delayMs: 900 });

          if (!procResp.ok) {
            const body = await jsonOrText(procResp);
            if (procResp.status === 429) {
              throw new Error(
                "Processor busy (429). Wait ~5 seconds and click Generate again.\n\n" +
                JSON.stringify(body, null, 2)
              );
            }
            throw new Error(`process failed (${procResp.status}): ${JSON.stringify(body, null, 2)}`);
          }

          const proc = await procResp.json();

          if (!proc.downloadUrl) {
            throw new Error(`process response missing downloadUrl: ${JSON.stringify(proc, null, 2)}`);
          }

          lastDownloadUrl = proc.downloadUrl;
          outPreview.src = proc.downloadUrl;
          dlBtn.disabled = false;

          setStatus("Done ✅", "ok");

          const perf = proc.perf
            ? `\nms: ${proc.perf.ms}\ncells: ${proc.perf.cellCount}\nout: ${proc.perf.outWidth}x${proc.perf.outHeight}`
            : "";

          setDebug(
            `uploadKey: ${up.key}\noutputKey: ${proc.outputKey || "(not provided)"}\nparams: ${JSON.stringify(proc.params || payload)}${perf}`
          );
        } catch (err) {
          setStatus(friendlyNetworkError(err), "err");
        } finally {
          goBtn.disabled = false;
          resetBtn.disabled = false;
        }
      });

      dlBtn.addEventListener("click", async () => {
        if (!lastDownloadUrl) return;
        try {
          const resp = await fetchWithRetry(lastDownloadUrl, {}, { tries: 2, delayMs: 500 });
          const blob = await resp.blob();

          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "halftone.png";
          document.body.appendChild(a);
          a.click();
          a.remove();
        } catch (err) {
          setStatus(friendlyNetworkError(err), "err");
        }
      });

      // Init labels
      cellSizeVal.textContent = cellSize.value;
      maxWidthVal.textContent = maxWidth.value;
      dotGainVal.textContent = dotGain.value;
      minDotVal.textContent = minDot.value;
      alphaThresholdVal.textContent = alphaThreshold.value;
      minCoverageVal.textContent = Number(minCoverage.value).toFixed(2);
      applyDtfSafeUiState();
    </script>
  </body>
</html>
